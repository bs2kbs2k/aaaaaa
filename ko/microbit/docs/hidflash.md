# Flashing via HID (CMSIS-DAP)

웹 프로그램이 보드와 HID로 연결되면, 하드웨어 디버거 인터페이스를 통해 프로그램을 보드에 업로드 할 수 있습니다. PXT 로컬호스트 서버는 HID 연결을 (웹 소켓으로) 대신하여 수행할 수 있으며, 일반 응용프로그램 앱들은 다양한 API들을 통해 HID에 접속할 수 있습니다.(API로 접속하는 것이 HID 프록시 방법으로 연결하는 것보다, 지연시간이 더 적을 것 입니다. )

이러한 상황은 일반적으로 작은 프로그램을 램에 로딩하는 과정을 통해 이루어지고, 그 다음에는 램으로 로딩할 페이지를 쓰게 되고, 그 다음에 프로그램이 실행되게 됩니다. 다음 페이지를 로딩하기 위해서는 먼저 로드된 프로그램은 유지하되, 데이터를 바꾸어 주어야 합니다. 내부적으로, @boardname@ 에 있는 DAPLink 소프트웨어가 같은 역할을 합니다.

HID 의 DAP 를 통해 프로그램을 업로드하는 것은, 프로그램을 드래그 앤 드롭해서 업로드하는 일반적인 방법보다는 느립니다. 왜냐하면 DAP 프로토콜로 전달하기 위한 오버헤드가 있으며, HID를 통한 처리량이 제한되어있기 때문입니다.(밀리초 당, 1 패킷, 최대 64비트) 또한, DAP 프로토콜은 모든 HID 패킷이 대역폭을 효과적으로 등분해야 한다고 알려져 있습니다. 그렇기 때문에, (HID 프록시를 사용했을 때) 일반적인 프로그램 업로드 속도가 14k/s 정도이며, 프로그램 업로드 완료에는 15초 정도 걸리는 것입니다. 이론적인 최대 속도는 25k/s 입니다.

[HF2](https://github.com/Microsoft/uf2/blob/master/hf2.md) 와 같은 커스텀 업로드 프로토콜의 경우, 60k/s 정도까지 빠르게 할 수 있지만, DAPLink 소프트웨어를 업데이트 해야합니다. 그리고, 그럼에도 불구하고 아주 빠르지는 않습니다.

## 프로그램 일부 업로드

그 대신, 변화된 페이지들만 변경할 수 있도록 하였습니다. 일반적인 소프트웨어 개발에서는 프로그램의 아주 작은 부분만 재배치되고 변경됩니다. 그리고, 프로그램의 대부분은 거의 변경되지 않습니다.(2개의 부트로더, 소프트웨어형 장치, 컴파일된 C++ 런타임)

이러한 방법은 조그만 프로그램이 모든 페이지의 체크섬을 먼저 계산해 확인하는 과정을 통해서 가능하게 됩니다. 그렇게 읽어들인 후, 업로드 되어있는 프로그램에서 읽혀진 체크섬 데이터는, 업로드할 프로그램의 `.hex` 페이지의 체크섬들과 비교가 됩니다. 그 다음에는 업로드 되어있는 페이지의 체크섬과 다른 페이지들만 업로드됩니다.

체크섬 알고리즘으로 사용된 방법은 [Murmur3](https://en.wikipedia.org/wiki/MurmurHash#MurmurHash3) 입니다. 이 알고리즘은 정렬되지 않은 데이터나 데이터 길이 해싱 정보에 대한 체크를 하지 않도록 단순화 되었기 때문에, 블록 데이터들의 해시 값이나 길이는 같게 됩니다.

Murmur3 해시 알고리즘은 매우 빠르기 때문에 선택되었습니다.(CRC32 보다 4배 정도 빠르고, SHA256 보다는 15배 정도 빠릅니다.) 전체 프로그램 데이터에 대한 체크섬을 검사하는 것은 200ms 정도의 시간이 걸립니다.

실제로, 32비트 Murmur3 (서로 다른 시작 위치를 사용하는) 해시 알고리즘을 병렬처리 시키면, 64비트 체크섬 데이터를 만들어낼 수 있습니다.

## 해시 데이터 길이 분석

이런 방법의 해시 알고리즘을 사용함에 따라서, 프로그램 데이터 페이지에서 충돌 문제가 생길 수 있는 확률을 계산해 볼 수 있습니다. 다음과 같이 가정하고 계산해 볼 수 있습니다.:

* 프로그램 해시 데이터는 균등 분포(uniform distribution)이다.
* 사용자는 10M(1천만) 명이라고 생각한다.
* 각각의 사용자가 50시간 동안 프로그래밍하고 매 2분마다 프로그램을 업로드하면, 50시간 동안 1500번 프로그램을 업로드하게 된다.
* 각 업로드 과정에서 10 개의 프로그램 데이터 페이지를 교체한다고 한다.

64 비트의 해시 데이터를 사용한다고 하면, 페이지 데이터 충돌 오류가 발생할 확률은 `1 - ((2^64 - 1) / 2^64) ^ (1e7 * 1500 * 10)` 로 계산할 수 있고, 그 결과 값은 `0.000016` 가 됩니다.(Bing 검색 엔진으로는 맞는 계산이 나오고; Google 은 `0` 이라는 잘못된 결과가 나옵니다) 32 비트의 해시 데이터를 사용하고, 100만 명의 사용자만 가정하는 경우에는 `97%` 의 데이터 충돌 가능성으로 계산할 수 있습니다. 해시 데이터가 모두 같을 수 있다라는 것에는 궁금증이 남지만, `0.000016` 만큼의 가능성은 있다는 것을 알 수 있습니다.